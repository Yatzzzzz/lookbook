'use client';

import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { useQuery } from "@tanstack/react-query";
import { Loader2 } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { useState, useEffect } from "react";
import BottomNav from "@/components/BottomNav";
import { createClientComponentClient } from '@supabase/auth-helpers-nextjs';
import { Avatar, AvatarImage, AvatarFallback } from "@/components/ui/avatar";
import SupabaseImage from "@/components/ui/supabase-image";
import { QueryClientProvider } from "@tanstack/react-query";
import { queryClient } from "@/lib/queryClient";

interface BattleItem {
  id: string;
  username?: string;
  avatar_url?: string;
  image_url?: string;
  caption?: string;
  option1_url?: string;
  option2_url?: string;
  selectedOption?: number;
}

function BattlePageContent() {
  const { toast } = useToast();
  const [battles, setBattles] = useState<Record<string, BattleItem>>({});
  const [battleItems, setBattleItems] = useState<BattleItem[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const supabase = createClientComponentClient();

  useEffect(() => {
    async function fetchBattleItems() {
      try {
        setIsLoading(true);
        console.log('========= DEBUG: STARTING BATTLE ITEMS FETCH =========');
        
        // Check the battle storage bucket first
        const { data: storageData, error: storageError } = await supabase
          .storage
          .from('battle')
          .list('', {
            limit: 100,
            sortBy: { column: 'name', order: 'desc' }
          });
          
        if (storageError) {
          console.error('Error checking battle storage bucket:', storageError);
          throw storageError;
        }
        
        console.log('Storage bucket contents:', storageData);
        
        // Process folders in the storage bucket
        const possibleFolders = storageData?.filter(item => !item.name.includes('.')) || [];
        console.log(`Found ${possibleFolders.length} potential user folders:`, possibleFolders.map(f => f.name));
        
        if (possibleFolders.length === 0) {
          // Try to find individual images if there are no folders
          const imageFiles = storageData?.filter(item => 
            item.name.endsWith('.jpg') || 
            item.name.endsWith('.jpeg') || 
            item.name.endsWith('.png') || 
            item.name.endsWith('.gif')) || [];
            
          if (imageFiles.length > 0) {
            console.log(`Found ${imageFiles.length} image files in root of battle bucket`);
            
            // Create battle items from individual images
            const items: BattleItem[] = [];
            
            for (const file of imageFiles) {
              // Get public URL for the image
              const { data: urlData } = await supabase
                .storage
                .from('battle')
                .getPublicUrl(file.name);
                
              if (!urlData || !urlData.publicUrl) {
                console.error(`Failed to get public URL for ${file.name}`);
                continue;
              }
              
              // Determine if this is a main, option1, or option2 image based on filename
              let itemType = 'main';
              if (file.name.toLowerCase().includes('option1')) {
                itemType = 'option1';
              } else if (file.name.toLowerCase().includes('option2')) {
                itemType = 'option2';
              }
              
              console.log(`Image ${file.name} categorized as ${itemType}`);
              
              // Find or create a battle item for this image
              const existingItemIndex = items.findIndex(item => 
                file.name.includes(item.id) || (item.id && file.name.includes(item.id))
              );
              
              if (existingItemIndex >= 0) {
                // Add to existing item
                if (itemType === 'main') {
                  items[existingItemIndex].image_url = urlData.publicUrl;
                } else if (itemType === 'option1') {
                  items[existingItemIndex].option1_url = urlData.publicUrl;
                } else if (itemType === 'option2') {
                  items[existingItemIndex].option2_url = urlData.publicUrl;
                }
              } else {
                // Create new item
                const newItem: BattleItem = {
                  id: file.id || file.name,
                  username: 'User',
                  caption: 'Which option do you prefer?'
                };
                
                if (itemType === 'main') {
                  newItem.image_url = urlData.publicUrl;
                } else if (itemType === 'option1') {
                  newItem.option1_url = urlData.publicUrl;
                } else if (itemType === 'option2') {
                  newItem.option2_url = urlData.publicUrl;
                }
                
                items.push(newItem);
              }
            }
            
            if (items.length > 0) {
              console.log(`Created ${items.length} battle items from individual images`);
              setBattleItems(items);
              
              // Also add to battles state
              const battlesRecord: Record<string, BattleItem> = {};
              items.forEach(item => {
                if (item.id) {
                  battlesRecord[item.id] = item;
                }
              });
              
              setBattles(battlesRecord);
              setIsLoading(false);
              return;
            }
          }
          
          // If we got here, no valid battle content was found
          setError('No battle images found. Please check your Supabase storage bucket and upload battle images.');
          setIsLoading(false);
          return;
        }
        
        // Process each user folder
        const items: BattleItem[] = [];
        
        for (const folder of possibleFolders) {
          const username = folder.name;
          console.log(`Examining folder for user: ${username}`);
          
          // Get all files in this folder
          const { data: folderFiles, error: folderError } = await supabase
            .storage
            .from('battle')
            .list(username, {
              sortBy: { column: 'name', order: 'asc' }
            });
            
          if (folderError) {
            console.error(`Error listing files in folder ${username}:`, folderError);
            continue;
          }
          
          console.log(`Found ${folderFiles?.length || 0} files in folder ${username}:`, folderFiles);
          
          if (!folderFiles || folderFiles.length === 0) {
            console.log(`No files found in folder ${username}`);
            continue;
          }
          
          // Group files by timestamp to find related images (main, option1, option2)
          const battleSets: Record<string, BattleItem> = {};
          
          // Process each file in the folder
          for (const file of folderFiles) {
            // Skip non-image files
            if (!file.name.endsWith('.jpg') && !file.name.endsWith('.jpeg') && 
                !file.name.endsWith('.png') && !file.name.endsWith('.gif')) {
              console.log(`Skipping non-image file: ${file.name}`);
              continue;
            }
            
            console.log(`Processing file: ${file.name}`);
            
            // Try to extract a timestamp and type from the filename
            let timestamp = file.name.split('.')[0]; // Default to filename without extension
            let type = 'main'; // Default type
            
            // Extract timestamp and type from filename
            if (file.name.includes('-')) {
              const parts = file.name.split('-');
              if (parts.length >= 2) {
                // Try to identify parts
                if (/^\d+$/.test(parts[0])) {
                  // First part is a number, likely a timestamp
                  timestamp = parts[0];
                  // Second part might be a type
                  const typePart = parts[1].split('.')[0].toLowerCase();
                  if (typePart.includes('main')) {
                    type = 'main';
                  } else if (typePart.includes('option1')) {
                    type = 'option1';
                  } else if (typePart.includes('option2')) {
                    type = 'option2';
                  }
                } else if (parts[0].toLowerCase().includes('main')) {
                  type = 'main';
                  timestamp = parts[1].split('.')[0];
                } else if (parts[0].toLowerCase().includes('option1')) {
                  type = 'option1';
                  timestamp = parts[1].split('.')[0];
                } else if (parts[0].toLowerCase().includes('option2')) {
                  type = 'option2';
                  timestamp = parts[1].split('.')[0];
                }
              }
            } else {
              // No hyphen, check if filename contains type indicators
              const lowerName = file.name.toLowerCase();
              if (lowerName.includes('main')) {
                type = 'main';
              } else if (lowerName.includes('option1')) {
                type = 'option1';
              } else if (lowerName.includes('option2')) {
                type = 'option2';
              }
            }
            
            console.log(`Parsed filename: timestamp=${timestamp}, type=${type}`);
            
            // Get public URL for this file
            const { data: urlData } = await supabase.storage
              .from('battle')
              .getPublicUrl(`${username}/${file.name}`);
              
            if (!urlData || !urlData.publicUrl) {
              console.error(`Failed to get public URL for ${username}/${file.name}`);
              continue;
            }
            
            console.log(`Generated public URL for ${file.name}: ${urlData.publicUrl}`);
            
            // Create or update a battle set entry
            if (!battleSets[timestamp]) {
              battleSets[timestamp] = {
                id: `${username}-${timestamp}`,
                username: username,
                caption: 'Which option do you prefer?'
              };
            }
            
            // Add the appropriate URL based on type
            if (type === 'main') {
              battleSets[timestamp].image_url = urlData.publicUrl;
            } else if (type === 'option1') {
              battleSets[timestamp].option1_url = urlData.publicUrl;
            } else if (type === 'option2') {
              battleSets[timestamp].option2_url = urlData.publicUrl;
            }
          }
          
          // Add valid battle sets to the items array
          Object.values(battleSets).forEach(battleSet => {
            // A valid battle set needs at least one option
            if (battleSet.option1_url || battleSet.option2_url) {
              // If no main image but at least one option, use first option as main
              if (!battleSet.image_url) {
                battleSet.image_url = battleSet.option1_url || battleSet.option2_url;
              }
              items.push(battleSet);
            }
          });
        }
        
        if (items.length > 0) {
          console.log(`Successfully created ${items.length} battle items from user folders`);
          setBattleItems(items);
          
          // Also add to battles state
          const battlesRecord: Record<string, BattleItem> = {};
          items.forEach(item => {
            if (item.id) {
              battlesRecord[item.id] = item;
            }
          });
          
          setBattles(battlesRecord);
        } else {
          setError('No valid battle sets found. Each battle needs at least one option image.');
        }
      } catch (error) {
        console.error('Error fetching battle items:', error);
        setError('Failed to load battle items. Please try again later.');
      } finally {
        setIsLoading(false);
      }
    }
    
    fetchBattleItems();
  }, [supabase]);

  const handleSelection = (battleId: string, optionNumber: number) => {
    setBattles(prev => ({
      ...prev,
      [battleId]: {
        ...prev[battleId],
        selectedOption: optionNumber
      }
    }));

    // Update battleItems as well
    setBattleItems(prev => prev.map(item => 
      item.id === battleId 
        ? { ...item, selectedOption: optionNumber } 
        : item
    ));

    toast({
      title: "Selection recorded!",
      description: `You selected option ${optionNumber}. Thanks for your input!`,
    });
    
    // In a real app, you would save this vote to the database
    // For example:
    // supabase.from('battle_votes').insert({
    //   battle_id: battleId,
    //   option: optionNumber,
    //   user_id: currentUserId
    // })
  };

  const renderBattles = () => {
    if (isLoading) {
      return (
        <div className="flex flex-col items-center justify-center min-h-[70vh]">
          <Loader2 className="h-12 w-12 text-primary animate-spin" />
          <p className="mt-4 text-sm text-muted-foreground">Loading battles...</p>
        </div>
      );
    }

    if (error) {
      return (
        <div className="flex flex-col items-center justify-center min-h-[70vh]">
          <p className="text-red-500 text-center">{error}</p>
          <Button 
            className="mt-4" 
            variant="outline" 
            onClick={() => window.location.reload()}
          >
            Try Again
          </Button>
        </div>
      );
    }

    if (battleItems.length === 0) {
      return (
        <div className="flex flex-col items-center justify-center min-h-[70vh]">
          <p className="text-center text-muted-foreground">No battle looks available at the moment.</p>
        </div>
      );
    }

    // Render all battle items
    return (
      <div className="grid gap-8 py-4">
        {battleItems.map((battle) => (
          <Card key={battle.id} className="overflow-hidden border rounded-lg">
            <CardContent className="p-0">
              <div className="p-4 border-b">
                <div className="flex items-center gap-2">
                  <Avatar className="h-8 w-8">
                    <AvatarImage src={battle.avatar_url || ''} alt={battle.username || 'User'} />
                    <AvatarFallback>{(battle.username || 'U').charAt(0).toUpperCase()}</AvatarFallback>
                  </Avatar>
                  <div className="font-medium">{battle.username || 'Anonymous'}</div>
                </div>
                <p className="mt-2 text-sm text-gray-500">{battle.caption || 'Which option do you prefer?'}</p>
              </div>
              
              <div className="grid grid-cols-2 gap-1 p-1">
                {/* Main Image */}
                {battle.image_url && (
                  <div className="aspect-square relative col-span-2">
                    <SupabaseImage
                      src={battle.image_url}
                      alt="Main look"
                      fill
                      className="object-cover rounded-md"
                    />
                  </div>
                )}
                
                {/* Option 1 */}
                {battle.option1_url && (
                  <div 
                    className={`aspect-square relative cursor-pointer transition-all duration-200 
                      ${battle.selectedOption === 1 ? 'ring-4 ring-primary' : 'hover:opacity-90'}`}
                    onClick={() => handleSelection(battle.id, 1)}
                  >
                    <SupabaseImage
                      src={battle.option1_url}
                      alt="Option 1"
                      fill
                      className="object-cover rounded-md"
                    />
                  </div>
                )}
                
                {/* Option 2 */}
                {battle.option2_url && (
                  <div 
                    className={`aspect-square relative cursor-pointer transition-all duration-200 
                      ${battle.selectedOption === 2 ? 'ring-4 ring-primary' : 'hover:opacity-90'}`}
                    onClick={() => handleSelection(battle.id, 2)}
                  >
                    <SupabaseImage
                      src={battle.option2_url}
                      alt="Option 2"
                      fill
                      className="object-cover rounded-md"
                    />
                  </div>
                )}
              </div>
              
              <div className="p-4 flex justify-between">
                <Button 
                  variant="outline" 
                  size="sm" 
                  disabled={!battle.option1_url}
                  onClick={() => handleSelection(battle.id, 1)}
                  className={battle.selectedOption === 1 ? 'bg-primary text-primary-foreground' : ''}
                >
                  Option 1
                </Button>
                <Button 
                  variant="outline" 
                  size="sm" 
                  disabled={!battle.option2_url}
                  onClick={() => handleSelection(battle.id, 2)}
                  className={battle.selectedOption === 2 ? 'bg-primary text-primary-foreground' : ''}
                >
                  Option 2
                </Button>
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
    );
  };

  return (
    <div className="w-full max-w-full px-2 sm:px-4 mx-auto">
      {renderBattles()}
    </div>
  );
}

export default function BattlePage() {
  return (
    <QueryClientProvider client={queryClient}>
      <div className="min-h-screen bg-background">
        <div className="container max-w-full mx-auto pb-16">
          <BattlePageContent />
        </div>
        <BottomNav activeTab="/gallery/battle" />
      </div>
    </QueryClientProvider>
  );
}

