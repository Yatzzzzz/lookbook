'use client'; import React, { useState, useRef, useCallback } from 'react'; import { useQuery, QueryClient, QueryClientProvider } from '@tanstack/react-query'; import * as Tabs from '@radix-ui/react-tabs'; import { Camera, Upload, Loader2, ThumbsUp, AlertCircle, Info, X, Zap, Check } from 'lucide-react'; // Create a query client const queryClient = new QueryClient(); interface Look { look_id: string; image_url: string; caption: string; username: string; tags?: string[]; is_user_uploaded?: boolean; } interface OptionPair { id: number; left: Look; right: Look; } // Main component content function BattleContent() { const [userLook, setUserLook] = useState<Look | null>(null); const [optionPairs, setOptionPairs] = useState<OptionPair[]>([]); const [activePairIndex, setActivePairIndex] = useState<number>(0); const [selections, setSelections] = useState<Record<number, 'left' | 'right'>>({}); const [isCameraActive, setIsCameraActive] = useState<boolean>(false); const [isCapturing, setIsCapturing] = useState<boolean>(false); const videoRef = useRef<HTMLVideoElement>(null); const canvasRef = useRef<HTMLCanvasElement>(null); const fileInputRef = useRef<HTMLInputElement>(null); // Mock API for fetching option pairs const { data: lookOptions, isLoading, isError } = useQuery({ queryKey: ['/api/testpages/look-options'], queryFn: async () => { try { const response = await fetch('/api/testpages/look-options'); if (!response.ok) { throw new Error('Failed to fetch look options'); } return await response.json(); } catch (error) { console.error('Error fetching look options:', error); throw error; } }, }); // Generate pairs of options when user uploads a look const generateOptionPairs = useCallback((userImage: string) => { if (!lookOptions) return; // Create user look const newUserLook: Look = { look_id: 'user-look', image_url: userImage, caption: "Your uploaded outfit", username: "you", is_user_uploaded: true }; setUserLook(newUserLook); // Create option pairs (left and right) const pairs: OptionPair[] = []; for (let i = 0; i < lookOptions.length; i += 2) { if (i + 1 < lookOptions.length) { pairs.push({ id: i / 2, left: lookOptions[i], right: lookOptions[i + 1] }); } } setOptionPairs(pairs); setActivePairIndex(0); setSelections({}); }, [lookOptions]); // Handle camera activation const activateCamera = async () => { try { setIsCameraActive(true); if (!videoRef.current) return; const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio: false }); videoRef.current.srcObject = stream; videoRef.current.play(); } catch (error) { console.error("Error accessing camera:", error); setIsCameraActive(false); } }; // Handle camera capture const captureImage = () => { if (!videoRef.current || !canvasRef.current) return; setIsCapturing(true); const video = videoRef.current; const canvas = canvasRef.current; // Set canvas dimensions to match video canvas.width = video.videoWidth; canvas.height = video.videoHeight; // Draw video frame to canvas const context = canvas.getContext('2d'); if (context) { context.drawImage(video, 0, 0, canvas.width, canvas.height); // Convert to image URL const imageUrl = canvas.toDataURL('image/jpeg'); // Stop camera stream const stream = video.srcObject as MediaStream; stream.getTracks().forEach(track => track.stop()); // Reset state and use the captured image setIsCameraActive(false); setIsCapturing(false); // Generate option pairs generateOptionPairs(imageUrl); } }; // Handle file upload const handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>) => { const file = event.target.files?.[0]; if (!file) return; const reader = new FileReader(); reader.onload = (e) => { const imageUrl = e.target?.result as string; generateOptionPairs(imageUrl); }; reader.readAsDataURL(file); }; // Handle selection const handleSelection = (pairId: number, selection: 'left' | 'right') => { setSelections(prev => ({ ...prev, [pairId]: selection })); // Move to next pair after a short delay setTimeout(() => { if (activePairIndex < optionPairs.length - 1) { setActivePairIndex(activePairIndex + 1); } }, 500); }; // Handle camera close const closeCamera = () => { if (videoRef.current) { const stream = videoRef.current.srcObject as MediaStream; if (stream) { stream.getTracks().forEach(track => track.stop()); } } setIsCameraActive(false); }; // Reset everything const resetAll = () => { setUserLook(null); setOptionPairs([]); setActivePairIndex(0); setSelections({}); setIsCameraActive(false); closeCamera(); }; // Loading state if (isLoading) { return ( <div className="max-w-6xl mx-auto px-4 py-8 flex flex-col items-center justify-center min-h-[60vh]"> <div className="flex flex-col items-center"> <Loader2 className="h-12 w-12 text-blue-500 animate-spin mb-4" /> <h1 className="text-xl font-semibold">Loading Style Options...</h1> <p className="text-gray-500 mt-2">Preparing fashion combinations for you</p> </div> </div> ); } // Error state if (isError || !lookOptions) { return ( <div className="max-w-6xl mx-auto px-4 py-8 flex flex-col items-center justify-center min-h-[60vh]"> <div className="flex flex-col items-center text-center"> <AlertCircle className="h-12 w-12 text-red-500 mb-4" /> <h1 className="text-xl font-semibold">Something went wrong</h1> <p className="text-gray-500 mt-2 max-w-md">We couldn&apos;t load style options. Please try again later.</p> </div> </div> ); } // Upload screen (no user look yet) if (!userLook) { return ( <div className="max-w-6xl mx-auto px-4 py-8"> <div className="flex flex-col mb-8"> <h1 className="text-3xl font-bold">Style Completion Battle</h1> <p className="text-gray-500 mt-2">Upload your outfit and select the best complementary pieces to complete your look</p> </div> <div className="bg-white rounded-xl shadow-sm border overflow-hidden"> <div className="px-6 py-4 border-b"> <h2 className="text-xl font-semibold">Upload Your Outfit</h2> </div> {isCameraActive ? ( <div className="p-6"> <div className="relative rounded-lg overflow-hidden bg-white aspect-[3/4] max-w-md mx-auto mb-4"> <video ref={videoRef} className="w-full h-full object-cover" playsInline autoPlay muted /> <button onClick={closeCamera} className="absolute top-2 right-2 p-2 bg-gray-100/80 rounded-full text-white" aria-label="Close camera" > <X className="h-5 w-5" /> </button> </div> <div className="flex justify-center"> <button onClick={captureImage} disabled={isCapturing} className="px-6 py-3 bg-blue-500 hover:bg-blue-600 text-white rounded-full font-medium flex items-center gap-2 disabled:opacity-70" > {isCapturing ? ( <> <Loader2 className="h-5 w-5 animate-spin" /> Capturing... </> ) : ( <> <Camera className="h-5 w-5" /> Capture Photo </> )} </button> </div> {/* Hidden canvas for capture */} <canvas ref={canvasRef} className="hidden" /> </div> ) : ( <div className="p-6 flex flex-col items-center"> <div className="mb-8 text-center max-w-md"> <p className="text-gray-600"> Take a photo of your outfit or upload an existing image to get started. We&apos;ll suggest complementary items to complete your look! </p> </div> <div className="flex flex-wrap gap-4 justify-center"> <button onClick={activateCamera} className="px-6 py-3 bg-blue-500 hover:bg-blue-600 text-white rounded-full font-medium flex items-center gap-2" > <Camera className="h-5 w-5" /> Take Photo </button> <button onClick={() => fileInputRef.current?.click()} className="px-6 py-3 bg-gray-100 hover:bg-white text-white rounded-full font-medium flex items-center gap-2" > <Upload className="h-5 w-5" /> Upload Image </button> <input ref={fileInputRef} type="file" accept="image/*" onChange={handleFileUpload} className="hidden" /> </div> </div> )} </div> </div> ); } // Get current option pair const currentPair = optionPairs[activePairIndex]; const currentSelection = selections[currentPair?.id]; // Battle screen (user has uploaded a look) return ( <div className="max-w-6xl mx-auto px-4 py-8"> <div className="flex flex-col mb-8"> <h1 className="text-3xl font-bold">Style Completion Battle</h1> <p className="text-gray-500 mt-2">Choose the best item to complete your look</p> </div> <div className="bg-white rounded-xl shadow-sm border overflow-hidden"> <div className="px-6 py-4 border-b flex justify-between items-center"> <h2 className="text-xl font-semibold"> Option {activePairIndex + 1} of {optionPairs.length} </h2> <button onClick={resetAll} className="text-sm text-red-500 hover:text-red-600" > Start Over </button> </div> <div className="grid grid-cols-1 sm:grid-cols-3 gap-4 p-6"> {/* Left option */} <div className={`relative p-2 rounded-lg border-2 ${currentSelection === 'left' ? 'border-green-500 bg-green-50' : 'border-transparent hover:border-gray-300'} transition-colors cursor-pointer order-2 sm:order-1`} onClick={() => handleSelection(currentPair.id, 'left')} > {currentSelection === 'left' && ( <div className="absolute top-2 right-2 bg-green-500 text-white rounded-full p-1 z-10"> <Check className="h-4 w-4" /> </div> )} <div className="aspect-[3/4] overflow-hidden rounded-md mb-2"> <img src={currentPair.left.image_url} alt={currentPair.left.caption} className="w-full h-full object-cover" /> </div> <div className="text-center"> <span className="inline-block px-2 py-0.5 bg-purple-100 text-purple-800 text-xs font-medium rounded-full mb-1">Option 1</span> <p className="text-sm font-medium">{currentPair.left.caption}</p> </div> </div> {/* Center - User Look */} <div className="p-2 border-2 border-blue-500 rounded-lg bg-blue-50 order-1 sm:order-2 mb-4 sm:mb-0"> <div className="aspect-[3/4] overflow-hidden rounded-md mb-2"> <img src={userLook.image_url} alt={userLook.caption} className="w-full h-full object-cover" /> </div> <div className="text-center"> <span className="inline-block px-2 py-0.5 bg-blue-100 text-blue-800 text-xs font-medium rounded-full mb-1">Your Outfit</span> <p className="text-sm font-medium">Choose a complement on either side</p> </div> </div> {/* Right option */} <div className={`relative p-2 rounded-lg border-2 ${currentSelection === 'right' ? 'border-green-500 bg-green-50' : 'border-transparent hover:border-gray-300'} transition-colors cursor-pointer order-3`} onClick={() => handleSelection(currentPair.id, 'right')} > {currentSelection === 'right' && ( <div className="absolute top-2 right-2 bg-green-500 text-white rounded-full p-1 z-10"> <Check className="h-4 w-4" /> </div> )} <div className="aspect-[3/4] overflow-hidden rounded-md mb-2"> <img src={currentPair.right.image_url} alt={currentPair.right.caption} className="w-full h-full object-cover" /> </div> <div className="text-center"> <span className="inline-block px-2 py-0.5 bg-purple-100 text-purple-800 text-xs font-medium rounded-full mb-1">Option 2</span> <p className="text-sm font-medium">{currentPair.right.caption}</p> </div> </div> </div> <div className="px-6 py-4 border-t bg-gray-50"> <p className="text-gray-600 text-center"> Click on the item that would best complement your outfit </p> {/* Progress bar */} <div className="mt-4 mb-4"> <div className="flex justify-between text-xs text-gray-500 mb-1"> <span>Progress</span> <span>{Object.keys(selections).length} of {optionPairs.length} selections</span> </div> <div className="w-full bg-gray-200 rounded-full h-2"> <div className="bg-blue-500 h-2 rounded-full transition-all duration-300" style={{ width: `${(Object.keys(selections).length / optionPairs.length) * 100}%` }} /> </div> </div> {/* Show results if all selections are made */} {Object.keys(selections).length === optionPairs.length && ( <div className="mt-6 p-4 rounded-lg bg-blue-100 text-blue-800 flex items-center gap-3"> <Zap className="h-6 w-6 text-blue-500" /> <div> <p className="font-semibold">All selections complete!</p> <p className="text-sm mt-1"> Your style profile is complete. We've analyzed your preferences and will recommend similar items in the future. </p> </div> </div> )} </div> </div> </div> ); } // Export with QueryClientProvider export default function BattlePage() { return ( <QueryClientProvider client={queryClient}> <BattleContent /> </QueryClientProvider> ); } 