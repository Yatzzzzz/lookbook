import { NextRequest, NextResponse } from 'next/server'; import { createClient } from '@supabase/supabase-js'; // Server-side Supabase client with admin privileges to bypass RLS const supabaseAdmin = createClient( process.env.NEXT_PUBLIC_SUPABASE_URL || '', process.env.SUPABASE_SERVICE_ROLE_KEY || '', { auth: { autoRefreshToken: false, persistSession: false } } ); export async function GET(_: NextRequest) { try { console.log('Initializing database settings...'); // First check if RLS is causing issues on look_ratings table // by trying to fix the policies await supabaseAdmin.rpc('query', { query: ` -- Update RLS for look_ratings table to fix authentication issues -- First, ensure RLS is enabled (but handled properly) ALTER TABLE look_ratings ENABLE ROW LEVEL SECURITY; -- Drop any existing policies DROP POLICY IF EXISTS "Anyone can view ratings" ON look_ratings; DROP POLICY IF EXISTS "Users can only create/update their own ratings" ON look_ratings; DROP POLICY IF EXISTS "Allow all operations on look_ratings" ON look_ratings; -- Create properly scoped policies -- 1. Anyone can view ratings CREATE POLICY "Anyone can view ratings" ON look_ratings FOR SELECT USING (true); -- 2. Authenticated users can rate (insert/update) CREATE POLICY "Authenticated users can rate" ON look_ratings FOR INSERT WITH CHECK (auth.uid() = user_id); -- 3. Users can update their own ratings CREATE POLICY "Users can update their own ratings" ON look_ratings FOR UPDATE USING (auth.uid() = user_id); -- 4. Users can delete their own ratings CREATE POLICY "Users can delete their own ratings" ON look_ratings FOR DELETE USING (auth.uid() = user_id); -- Service role bypass CREATE POLICY "Service role can manage all ratings" ON look_ratings USING (auth.jwt() ->> 'role' = 'service_role'); -- Make sure looks table has the feature_in column DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'looks' AND column_name = 'feature_in') THEN ALTER TABLE looks ADD COLUMN feature_in TEXT[] DEFAULT ARRAY['gallery']; END IF; -- Ensure any null feature_in values are converted to arrays UPDATE looks SET feature_in = ARRAY['gallery'] WHERE feature_in IS NULL; END $$; -- Make sure the rating_count and avg_rating columns exist in looks table DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'looks' AND column_name = 'rating_count') THEN ALTER TABLE looks ADD COLUMN rating_count INTEGER DEFAULT 0; END IF; IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'looks' AND column_name = 'avg_rating') THEN ALTER TABLE looks ADD COLUMN avg_rating NUMERIC(3,2) DEFAULT 0; END IF; END $$; -- Fix any update_look_rating_stats() issues CREATE OR REPLACE FUNCTION update_look_rating_stats() RETURNS TRIGGER AS $$ DECLARE look_id_val UUID; rating_count_val INTEGER; avg_rating_val NUMERIC(3,2); BEGIN -- Determine which look_id to update IF (TG_OP = 'DELETE') THEN look_id_val := OLD.look_id; ELSE look_id_val := NEW.look_id; END IF; IF look_id_val IS NULL THEN RETURN NULL; END IF; -- Calculate new rating statistics for this look SELECT COUNT(*) AS rating_count, COALESCE(AVG(rating)::NUMERIC(3,2), 0) AS avg_rating INTO rating_count_val, avg_rating_val FROM look_ratings WHERE look_id = look_id_val; -- Update the looks table with new statistics with proper WHERE clause UPDATE looks SET rating_count = rating_count_val, avg_rating = avg_rating_val, rating = avg_rating_val::TEXT WHERE look_id = look_id_val; RETURN NULL; END; $$ LANGUAGE plpgsql; -- Recreate the trigger DROP TRIGGER IF EXISTS update_look_rating_stats_trigger ON look_ratings; CREATE TRIGGER update_look_rating_stats_trigger AFTER INSERT OR UPDATE OR DELETE ON look_ratings FOR EACH ROW EXECUTE FUNCTION update_look_rating_stats(); ` }); console.log('Database initialized successfully'); return NextResponse.json({ success: true, message: 'Database initialized successfully' }); } catch (error) { console.error('Error initializing database:', error); return NextResponse.json({ success: false, error: error instanceof Error ? error.message : 'Unknown error initializing database' }, { status: 500 }); } } 