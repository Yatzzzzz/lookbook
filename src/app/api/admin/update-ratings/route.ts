import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs'; import { cookies } from 'next/headers'; import { NextRequest, NextResponse } from 'next/server'; // Function to recreate the database triggers and functions if needed const recreateTriggers = async (supabase: any) => { try { // This SQL recreates the key triggers and functions const sql = ` -- Function to update look rating statistics CREATE OR REPLACE FUNCTION update_look_rating_stats() RETURNS TRIGGER AS $$ DECLARE look_id_val UUID; avg_rating_val NUMERIC(3,2); BEGIN -- Determine which look_id to update IF (TG_OP = 'DELETE') THEN look_id_val := OLD.look_id; ELSE look_id_val := NEW.look_id; END IF; -- Calculate new rating statistics for this look SELECT COALESCE(AVG(rating)::NUMERIC(3,2), 0) AS avg_rating INTO avg_rating_val FROM look_ratings WHERE look_id = look_id_val; -- Update the looks table with new statistics using the rating column UPDATE looks SET rating = avg_rating_val::TEXT WHERE look_id = look_id_val; RETURN NULL; END; $$ LANGUAGE plpgsql; -- Drop and recreate the trigger DROP TRIGGER IF EXISTS update_look_rating_stats_trigger ON look_ratings; CREATE TRIGGER update_look_rating_stats_trigger AFTER INSERT OR UPDATE OR DELETE ON look_ratings FOR EACH ROW EXECUTE FUNCTION update_look_rating_stats(); -- Function to update the top_rated_look flag CREATE OR REPLACE FUNCTION update_top_rated_flags() RETURNS VOID AS $$ BEGIN -- Reset all flags first UPDATE looks SET feature_in = array_remove(feature_in, 'top_rated'); -- Add top_rated flag to the top 50 rated looks (using a subquery to count ratings) WITH rating_counts AS ( SELECT look_id, COUNT(*) AS rating_count, AVG(rating)::NUMERIC(3,2) AS avg_rating FROM look_ratings GROUP BY look_id ), top_rated AS ( SELECT look_id FROM rating_counts WHERE rating_count >= 5 ORDER BY avg_rating DESC, rating_count DESC LIMIT 50 ) UPDATE looks SET feature_in = array_append(feature_in, 'top_rated') FROM top_rated WHERE looks.look_id = top_rated.look_id; END; $$ LANGUAGE plpgsql; -- Run the update function SELECT update_top_rated_flags(); `; // Execute the SQL script const { error } = await supabase.rpc('exec_sql', { sql_query: sql }); if (error) throw error; return { success: true }; } catch (err) { console.error('Error recreating triggers:', err); return { success: false, error: err }; } }; // Function to synchronize all ratings const syncAllRatings = async (supabase: any) => { try { // This synchronizes all look ratings to only use the rating column const sql = ` -- Create a temporary table to store rating statistics CREATE TEMP TABLE IF NOT EXISTS temp_rating_stats AS SELECT look_id, COUNT(*) AS rating_count, AVG(rating)::NUMERIC(3,2) AS avg_rating FROM look_ratings GROUP BY look_id; -- Update the looks table with the calculated statistics UPDATE looks l SET rating = trs.avg_rating::TEXT FROM temp_rating_stats trs WHERE l.look_id = trs.look_id; -- Run the top rated update SELECT update_top_rated_flags(); -- Get stats about how many records were updated SELECT COUNT(*) AS total_looks, (SELECT COUNT(DISTINCT look_id) FROM look_ratings) AS rated_looks, (SELECT ROUND(AVG(cnt)) FROM (SELECT COUNT(*) AS cnt FROM look_ratings GROUP BY look_id) AS x) AS avg_ratings_per_look, (SELECT MAX(cnt) FROM (SELECT COUNT(*) AS cnt FROM look_ratings GROUP BY look_id) AS x) AS max_ratings_on_look FROM looks; `; // Execute the SQL script const { data, error } = await supabase.rpc('exec_sql', { sql_query: sql }); if (error) throw error; return { success: true, stats: data }; } catch (err) { console.error('Error syncing ratings:', err); return { success: false, error: err }; } }; // GET /api/admin/update-ratings - Get current rating stats export async function GET(request: NextRequest) { try { const cookieStore = cookies(); const supabase = createRouteHandlerClient({ cookies: () => cookieStore }); // Verify authentication const { data: { session } } = await supabase.auth.getSession(); if (!session?.user) { return NextResponse.json( { error: 'Unauthorized' }, { status: 401 } ); } // Check if user has admin privileges const { data: userData, error: userError } = await supabase .from('users') .select('role') .eq('id', session.user.id) .single(); if (userError || !userData || userData.role !== 'admin') { return NextResponse.json( { error: 'Permission denied' }, { status: 403 } ); } // Get rating statistics const { data, error } = await supabase.rpc('get_rating_stats'); if (error) { console.error('Error fetching rating stats:', error); return NextResponse.json( { error: 'Failed to fetch rating statistics' }, { status: 500 } ); } return NextResponse.json({ success: true, stats: data || { total_looks: 0, rated_looks: 0, avg_ratings_per_look: 0, max_ratings_on_look: 0 } }); } catch (err: any) { console.error('Error in rating stats API:', err); return NextResponse.json( { error: 'Internal server error', details: err.message }, { status: 500 } ); } } // POST /api/admin/update-ratings - Run rating synchronization export async function POST(request: NextRequest) { try { const cookieStore = cookies(); const supabase = createRouteHandlerClient({ cookies: () => cookieStore }); // Verify authentication const { data: { session } } = await supabase.auth.getSession(); if (!session?.user) { return NextResponse.json( { error: 'Unauthorized' }, { status: 401 } ); } // Check if user has admin privileges const { data: userData, error: userError } = await supabase .from('users') .select('role') .eq('id', session.user.id) .single(); if (userError || !userData || userData.role !== 'admin') { return NextResponse.json( { error: 'Permission denied' }, { status: 403 } ); } // Get request body const body = await request.json(); const { action } = body; if (action === 'recreate_triggers') { const result = await recreateTriggers(supabase); if (!result.success) { return NextResponse.json( { error: 'Failed to recreate triggers', details: result.error }, { status: 500 } ); } return NextResponse.json({ success: true, message: 'Database triggers recreated successfully' }); } else if (action === 'sync_ratings') { const result = await syncAllRatings(supabase); if (!result.success) { return NextResponse.json( { error: 'Failed to sync ratings', details: result.error }, { status: 500 } ); } return NextResponse.json({ success: true, message: 'Ratings synchronized successfully', stats: result.stats }); } else { return NextResponse.json( { error: 'Invalid action. Must be "recreate_triggers" or "sync_ratings"' }, { status: 400 } ); } } catch (err: any) { console.error('Error in update ratings API:', err); return NextResponse.json( { error: 'Internal server error', details: err.message }, { status: 500 } ); } } 