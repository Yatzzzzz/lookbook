'use client'; import React, { useEffect, useState, useMemo } from 'react'; import { createClient } from '@supabase/supabase-js'; import Link from 'next/link'; import { useGalleryContext } from './layout'; import { useAuth } from '@/contexts/AuthContext'; import Masonry, { ResponsiveMasonry } from 'react-responsive-masonry'; // Initialize Supabase client const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || ''; const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || ''; if (!supabaseUrl || !supabaseKey) { console.error('Supabase configuration is missing. Please check your environment variables.'); } const supabase = createClient(supabaseUrl, supabaseKey); interface Look { look_id: string; user_id: string; username?: string; title?: string; description?: string; image_url: string; audience?: 'everyone' | 'following' | 'friends'; created_at: string; storage_path?: string; user?: { username: string } | { username: string }[] | null; verified?: boolean; // Added to track verified storage existence } // Add export const dynamic to prevent prerendering during build export const dynamic = 'force-dynamic'; export default function GalleryPage() { const { activeSubTab } = useGalleryContext(); const { user: authUser } = useAuth(); const [allLooks, setAllLooks] = useState<Look[]>([]); const [loading, setLoading] = useState(true); const [error, setError] = useState<string | null>(null); const [failedImages, setFailedImages] = useState<Set<string>>(new Set()); // Function to verify if a file exists in storage const verifyFileExists = async (path: string): Promise<boolean> => { try { // Use head request to check if file exists const { data } = await supabase.storage .from('looks') .createSignedUrl(path, 1); // Create a short-lived signed URL // If we get a signed URL, the file exists return !!data; } catch { return false; } }; // Add cache busting parameter to URLs const addCacheBuster = (url: string): string => { const cacheBuster = `cache=${Date.now()}`; return url.includes('?') ? `${url}&${cacheBuster}` : `${url}?${cacheBuster}`; }; // Fetch looks data from Supabase const fetchLooks = async () => { try { setLoading(true); console.log('Fetching looks from Supabase...'); // Store all images from various sources let allImagesWithMetadata: Look[] = []; // 1. Fetch looks from the database that have valid storage paths const { data: dbLooks, error: dbError } = await supabase .from('looks') .select('*, user:user_id(username)') .order('created_at', { ascending: false }); if (dbError) { console.error("Error fetching looks from database:", dbError); setError("Failed to load looks from database. Please try again later."); setLoading(false); return; } if (dbLooks && dbLooks.length > 0) { console.log(`Found ${dbLooks.length} looks in database`); // Process each look from database to get image URLs const looksWithValidPaths = dbLooks.filter(look => look.storage_path && // Ensure the look is active (not deleted) look.storage_path.length > 0 ); // Verify each look against storage const processedDbLooks = await Promise.all( looksWithValidPaths.map(async (look) => { try { // First verify that the file actually exists in storage if (look.storage_path) { const exists = await verifyFileExists(look.storage_path); if (!exists) { console.log(`Image no longer exists in storage: ${look.storage_path}`); return null; } } // Generate a URL for the image if needed if (!look.image_url || look.image_url.includes('undefined')) { const { data: imageUrl } = supabase.storage .from('looks') .getPublicUrl(look.storage_path!); return { ...look, image_url: addCacheBuster(imageUrl.publicUrl), username: look.user?.username || look.username || 'Anonymous', verified: true }; } return { ...look, image_url: addCacheBuster(look.image_url), username: look.user?.username || look.username || 'Anonymous', verified: true }; } catch (err) { console.error(`Error processing look ${look.look_id}:`, err); return null; } }) ); // Filter out any null values allImagesWithMetadata = processedDbLooks.filter(Boolean) as Look[]; } // 2. Fetch all folders in the "looks" bucket const { data: storageRootItems, error: rootError } = await supabase .storage .from('looks') .list('', { limit: 100, }); if (rootError) { console.error("Error listing storage bucket contents:", rootError); } else if (storageRootItems) { console.log(`Found ${storageRootItems.length} items in root of looks bucket`); // Find all direct image files in the root const rootImageFiles = storageRootItems.filter(item => !item.name.includes('.') ? false : // Exclude folders item.name.endsWith('.jpg') || item.name.endsWith('.jpeg') || item.name.endsWith('.png') || item.name.endsWith('.gif') ); console.log(`Found ${rootImageFiles.length} image files in root of looks bucket`); // Process direct root images into looks const rootImagesWithMetadata = await Promise.all( rootImageFiles.map(async (file) => { try { // Verify the file exists (it should since we just got it from the list) const exists = await verifyFileExists(file.name); if (!exists) { return null; } const { data: urlData } = supabase.storage .from('looks') .getPublicUrl(file.name); // Create a look object for this file return { look_id: file.id, user_id: 'unknown', image_url: addCacheBuster(urlData.publicUrl), title: file.name.split('.')[0].replace(/-/g, ' '), storage_path: file.name, created_at: new Date(file.created_at).toISOString(), audience: 'everyone', verified: true } as Look; } catch (err) { console.error(`Error processing root image ${file.name}:`, err); return null; } }) ); // Add valid root images to our collection allImagesWithMetadata = [ ...allImagesWithMetadata, ...rootImagesWithMetadata.filter(Boolean) as Look[] ]; // Find folders (user directories) const folders = storageRootItems.filter(item => !item.name.includes('.')); console.log(`Found ${folders.length} folders in looks bucket`); // Process each folder (username folder) for (const folder of folders) { const username = folder.name; // List files in this folder const { data: folderFiles, error: folderError } = await supabase .storage .from('looks') .list(username, { limit: 100 }); if (folderError) { console.error(`Error listing files in folder ${username}:`, folderError); continue; } if (!folderFiles || folderFiles.length === 0) { continue; } // Get image files from this folder const imageFiles = folderFiles.filter(file => file.name.endsWith('.jpg') || file.name.endsWith('.jpeg') || file.name.endsWith('.png') || file.name.endsWith('.gif') ); if (imageFiles.length === 0) { continue; } console.log(`Found ${imageFiles.length} images in folder ${username}`); // Process each image file in the folder into a look const folderImagesWithMetadata = await Promise.all( imageFiles.map(async (file) => { try { const storagePath = `${username}/${file.name}`; // Verify the file exists (it should since we just got it from the list) const exists = await verifyFileExists(storagePath); if (!exists) { return null; } const { data: urlData } = supabase.storage .from('looks') .getPublicUrl(storagePath); // Create a look object for this file return { look_id: file.id, user_id: 'unknown', username: username, image_url: addCacheBuster(urlData.publicUrl), title: file.name.split('.')[0].replace(/-/g, ' '), storage_path: storagePath, created_at: new Date(file.created_at).toISOString(), audience: 'everyone', verified: true } as Look; } catch (err) { console.error(`Error processing image ${file.name} in folder ${username}:`, err); return null; } }) ); // Add valid folder images to our collection allImagesWithMetadata = [ ...allImagesWithMetadata, ...folderImagesWithMetadata.filter(Boolean) as Look[] ]; } } // Remove any duplicates by storage_path (prefer db entries over storage entries) const uniqueLooks = allImagesWithMetadata.filter((look, index, self) => index === self.findIndex(l => l.storage_path === look.storage_path) ); // Sort by created_at (newest first) uniqueLooks.sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime() ); console.log(`Processed ${uniqueLooks.length} verified unique looks for display`); setAllLooks(uniqueLooks); } catch (err) { console.error("Unexpected error in fetchLooks:", err); setError("An unexpected error occurred. Please try again later."); } finally { setLoading(false); } }; useEffect(() => { fetchLooks(); // Check auth state const { data: { subscription: authSubscription } } = supabase.auth.onAuthStateChange( (event, session) => { if (event === 'SIGNED_IN' || event === 'SIGNED_OUT') { // Refresh the looks when auth state changes fetchLooks(); } } ); // Clear any stored URLs or image caches when component mounts const clearImageCache = () => { // This might help force reloading of images rather than using cached ones setFailedImages(new Set()); // Remove any URLs from session storage that might be used for caching try { const cacheKeys = Object.keys(sessionStorage).filter(key => key.startsWith('img_') || key.includes('looks') ); cacheKeys.forEach(key => sessionStorage.removeItem(key)); } catch (e) { // Ignore errors related to session storage access } }; clearImageCache(); return () => { authSubscription.unsubscribe(); }; }, []); // Handle image loading failure const handleImageError = (lookId: string, imageUrl: string) => { // Add to set of failed images setFailedImages(prev => { const newSet = new Set(prev); newSet.add(lookId); return newSet; }); // Optionally, you could also remove this look from the displayed list setAllLooks(prevLooks => prevLooks.filter(look => look.look_id !== lookId) ); console.log(`Image failed to load: ${imageUrl}`); }; // Filter looks based on active secondary tab const filteredLooks = useMemo(() => { if (allLooks.length === 0) return []; // Filter out any looks that have already failed to load const validLooks = allLooks.filter( look => !failedImages.has(look.look_id) && look.verified ); if (activeSubTab === 'all') return validLooks; if (activeSubTab === 'my-looks' && authUser) { return validLooks.filter(look => look.user_id === authUser.id); } if (activeSubTab === 'following') { return validLooks.filter(look => look.audience === 'following' || look.audience === 'everyone' ); } if (activeSubTab === 'friends') { return validLooks.filter(look => look.audience === 'friends' || look.audience === 'everyone' ); } return validLooks; }, [activeSubTab, allLooks, authUser, failedImages]); // Add utility to ensure images dimensions are properly calculated for masonry layout useEffect(() => { if (filteredLooks.length > 0 && !loading) { // Log to verify images are loading with natural dimensions console.log('Masonry layout: initializing with', filteredLooks.length, 'images'); // Force reflow/redraw after images are loaded const images = document.querySelectorAll('.masonry-img'); let loadedCount = 0; const totalImages = images.length; if (totalImages === 0) return; const handleImageLoad = () => { loadedCount++; if (loadedCount === totalImages) { console.log('Masonry layout: all images loaded with natural dimensions'); // Force masonry to recalculate layout window.dispatchEvent(new Event('resize')); } }; images.forEach(img => { if ((img as HTMLImageElement).complete) { handleImageLoad(); } else { img.addEventListener('load', handleImageLoad); } }); return () => { images.forEach(img => { img.removeEventListener('load', handleImageLoad); }); }; } }, [filteredLooks, loading]); // Add custom CSS styles to ensure proper masonry layout useEffect(() => { const style = document.createElement('style'); style.textContent = ` /* Ensure all masonry items maintain proper box sizing */ .masonry-item { box-sizing: border-box !important; } /* Ensure images render at their natural aspect ratio */ .masonry-img { display: block; width: 100%; height: auto !important; transition: opacity 0.3s ease; } /* Add hover effect */ .masonry-item-container { transition: transform 0.2s ease; overflow: hidden; } .masonry-item-container:hover { transform: translateY(-2px); } `; document.head.appendChild(style); return () => { document.head.removeChild(style); }; }, []); // Function to preload an image and get its dimensions const preloadImage = (src: string): Promise<{ width: number; height: number }> => { return new Promise((resolve, reject) => { const img = new Image(); img.onload = () => { resolve({ width: img.width, height: img.height }); }; img.onerror = () => { reject(new Error(`Failed to load image: ${src}`)); }; img.src = src; }); }; // Preload images before displaying them in the masonry layout useEffect(() => { if (filteredLooks.length > 0 && !loading) { // Preload the first few images to help with initial rendering const preloadCount = Math.min(filteredLooks.length, 8); const preloadPromises = filteredLooks .slice(0, preloadCount) .map(look => preloadImage(look.image_url)); Promise.allSettled(preloadPromises) .then(results => { console.log(`Preloaded ${results.filter(r => r.status === 'fulfilled').length}/${preloadCount} images for masonry layout`); // Force a redraw if needed window.dispatchEvent(new Event('resize')); }); } }, [filteredLooks, loading]); return ( <div className="w-full p-0 m-0"> {loading ? ( <div className="flex justify-center items-center h-64"> <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-gray-900"></div> </div> ) : error ? ( <div className="text-center p-4 text-red-500"> <p>Error loading images: {error}</p> <button className="mt-2 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600" onClick={() => fetchLooks()} > Try Again </button> </div> ) : filteredLooks.length === 0 ? ( <div className="text-center p-8"> <p className="text-lg text-[#222222] ">No images found for this filter.</p> <p className="text-[#444444] mt-2">Try a different filter or upload some looks!</p> </div> ) : ( <div className="masonry-wrapper"> <ResponsiveMasonry columnsCountBreakPoints={{ 0: 2, 640: 2, 768: 3, 1024: 4 }} > <Masonry gutter="20px" className="masonry-grid"> {filteredLooks.map((look) => ( <div key={look.look_id || look.storage_path} className="bg-white overflow-hidden mb-4 masonry-item masonry-item-container" > <Link href={`/gallery/look/${encodeURIComponent(look.storage_path || look.image_url.split('/').pop() || '')}`}> <div className="relative"> <img src={look.image_url} alt={look.title || "Fashion look"} className="w-full h-auto masonry-img" onError={(e) => { handleImageError(look.look_id, look.image_url); (e.target as HTMLImageElement).src = '/images/placeholder.jpg'; }} /> <div className="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/60 to-transparent p-2 text-xs text-white"> <div className="font-medium truncate"> {look.title || "Untitled Look"} </div> <div className="opacity-80"> By {look.username || "Anonymous"} </div> </div> </div> </Link> </div> ))} </Masonry> </ResponsiveMasonry> </div> )} </div> ); } 