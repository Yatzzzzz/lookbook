'use client'; import { Card, CardContent } from "@/components/ui/card"; import { Button } from "@/components/ui/button"; import { Loader2 } from "lucide-react"; import { useToast } from "@/hooks/use-toast"; import { useState, useEffect } from "react"; import BottomNav from "@/components/BottomNav"; import { createClientComponentClient } from '@supabase/auth-helpers-nextjs'; import { Avatar, AvatarImage, AvatarFallback } from "@/components/ui/avatar"; import SupabaseImage from "@/components/ui/supabase-image"; import { QueryClientProvider } from "@tanstack/react-query"; import { queryClient } from "@/lib/queryClient"; // Define interfaces interface BattleItem { id: string; username?: string; avatar_url?: string; image_url?: string; caption?: string; option1_url?: string; option2_url?: string; selectedOption?: number; } function BattlePageContent() { const { toast } = useToast(); const [battleItems, setBattleItems] = useState<BattleItem[]>([]); const [isLoading, setIsLoading] = useState(true); const [error, setError] = useState<string | null>(null); const supabase = createClientComponentClient(); useEffect(() => { async function fetchBattleItems() { try { setIsLoading(true); console.log('========= FETCHING BATTLE ITEMS ========='); // Check the battle storage bucket const { data: storageData, error: storageError } = await supabase .storage .from('battle') .list('', { limit: 100, sortBy: { column: 'name', order: 'desc' } }); if (storageError) { console.error('Error checking battle storage bucket:', storageError); throw storageError; } console.log('Storage bucket contents:', storageData); // First check if there are any files in the root directory const imageFiles = storageData?.filter(item => item.name.endsWith('.jpg') || item.name.endsWith('.jpeg') || item.name.endsWith('.png') || item.name.endsWith('.gif')) || []; if (imageFiles.length > 0) { console.log(`Found ${imageFiles.length} image files in root directory`); // Group the files by prefix to create battle sets const battleSets: Record<string, BattleItem> = {}; for (const file of imageFiles) { // Get the public URL const { data: urlData } = await supabase .storage .from('battle') .getPublicUrl(file.name); if (!urlData || !urlData.publicUrl) { console.error(`Failed to get public URL for ${file.name}`); continue; } console.log(`Generated public URL for ${file.name}: ${urlData.publicUrl}`); // Determine file type from filename let filePrefix = file.name.split('-')[0]; let fileType = 'main'; if (file.name.toLowerCase().includes('main')) { fileType = 'main'; } else if (file.name.toLowerCase().includes('option1')) { fileType = 'option1'; } else if (file.name.toLowerCase().includes('option2')) { fileType = 'option2'; } // Ensure we have a valid ID for grouping if (!filePrefix) { filePrefix = 'default'; } // Create or update battle set if (!battleSets[filePrefix]) { battleSets[filePrefix] = { id: filePrefix, username: 'User', caption: 'Which option do you prefer?' }; } // Add the URL to the appropriate field if (fileType === 'main') { battleSets[filePrefix].image_url = urlData.publicUrl; } else if (fileType === 'option1') { battleSets[filePrefix].option1_url = urlData.publicUrl; } else if (fileType === 'option2') { battleSets[filePrefix].option2_url = urlData.publicUrl; } } // Convert battle sets to array const items = Object.values(battleSets).filter(item => // Only include items that have at least one option item.option1_url || item.option2_url ); if (items.length > 0) { console.log(`Created ${items.length} battle items from root images`); setBattleItems(items); setIsLoading(false); return; } } // If no files in root, check for user folders const folders = storageData?.filter(item => !item.name.includes('.')) || []; console.log(`Found ${folders.length} potential user folders`); if (folders.length === 0) { setError('No battle images found. Upload battle images to your Supabase storage.'); setIsLoading(false); return; } // Process each folder const allItems: BattleItem[] = []; for (const folder of folders) { const username = folder.name; console.log(`Processing folder: ${username}`); // List files in this folder const { data: folderFiles, error: folderError } = await supabase .storage .from('battle') .list(username, { limit: 100 }); if (folderError) { console.error(`Error listing files in folder ${username}:`, folderError); continue; } if (!folderFiles || folderFiles.length === 0) { console.log(`No files found in folder ${username}`); continue; } console.log(`Found ${folderFiles.length} files in folder ${username}`); // Get image files const imageFiles = folderFiles.filter(file => file.name.endsWith('.jpg') || file.name.endsWith('.jpeg') || file.name.endsWith('.png') || file.name.endsWith('.gif') ); if (imageFiles.length === 0) { console.log(`No image files found in folder ${username}`); continue; } // Try to group related files by timestamp or prefix const battleSets: Record<string, BattleItem> = {}; for (const file of imageFiles) { // Get the public URL const { data: urlData } = await supabase .storage .from('battle') .getPublicUrl(`${username}/${file.name}`); if (!urlData || !urlData.publicUrl) { console.error(`Failed to get public URL for ${username}/${file.name}`); continue; } console.log(`Generated public URL for ${username}/${file.name}: ${urlData.publicUrl}`); // Try to determine set ID and file type let setId = file.name.split('.')[0]; // Default to filename without extension let fileType = 'main'; // Check for pattern in filename if (file.name.includes('-')) { const parts = file.name.split('-'); if (parts.length >= 2) { if (/^\d+$/.test(parts[0])) { // First part is numeric, likely a timestamp setId = parts[0]; // Check second part for type const typePart = parts[1].split('.')[0].toLowerCase(); if (typePart.includes('main')) { fileType = 'main'; } else if (typePart.includes('option1')) { fileType = 'option1'; } else if (typePart.includes('option2')) { fileType = 'option2'; } } else { // First part might be the type const typePart = parts[0].toLowerCase(); if (typePart.includes('main')) { fileType = 'main'; setId = parts[1].split('.')[0]; } else if (typePart.includes('option1')) { fileType = 'option1'; setId = parts[1].split('.')[0]; } else if (typePart.includes('option2')) { fileType = 'option2'; setId = parts[1].split('.')[0]; } } } } else { // Simple filename, check for type indicators const fileName = file.name.toLowerCase(); if (fileName.includes('main')) { fileType = 'main'; } else if (fileName.includes('option1')) { fileType = 'option1'; } else if (fileName.includes('option2')) { fileType = 'option2'; } } // Create or update battle set entry const fullSetId = `${username}-${setId}`; if (!battleSets[fullSetId]) { battleSets[fullSetId] = { id: fullSetId, username: username, caption: 'Which option do you prefer?' }; } // Add the URL to the appropriate field if (fileType === 'main') { battleSets[fullSetId].image_url = urlData.publicUrl; } else if (fileType === 'option1') { battleSets[fullSetId].option1_url = urlData.publicUrl; } else if (fileType === 'option2') { battleSets[fullSetId].option2_url = urlData.publicUrl; } } // Add valid battle sets to items Object.values(battleSets).forEach(set => { // A valid set needs at least one option if (set.option1_url || set.option2_url) { // If no main image, use first option as main if (!set.image_url) { set.image_url = set.option1_url || set.option2_url; } allItems.push(set); } }); } if (allItems.length > 0) { console.log(`Created ${allItems.length} battle items from user folders`); setBattleItems(allItems); } else { setError('No valid battle images found. Each battle needs at least one option image.'); } } catch (error) { console.error('Error fetching battle items:', error); setError('Failed to load battle items. Please try again later.'); } finally { setIsLoading(false); } } fetchBattleItems(); }, [supabase]); const handleSelection = (battleId: string, optionNumber: number) => { // Update selected option setBattleItems(prev => prev.map(item => item.id === battleId ? { ...item, selectedOption: optionNumber } : item )); // Show toast notification toast({ title: "Selection recorded!", description: `You selected option ${optionNumber}. Thanks for your input!`, }); // In a real app, you would save this vote to the database // supabase.from('battle_votes').insert({ // battle_id: battleId, // option: optionNumber // }) }; if (isLoading) { return ( <div className="flex flex-col items-center justify-center min-h-[70vh]"> <Loader2 className="h-12 w-12 text-primary animate-spin" /> <p className="mt-4 text-sm text-muted-foreground">Loading battles...</p> </div> ); } if (error) { return ( <div className="flex flex-col items-center justify-center min-h-[70vh]"> <p className="text-red-500 text-center">{error}</p> <Button className="mt-4" variant="outline" onClick={() => window.location.reload()} > Try Again </Button> </div> ); } if (battleItems.length === 0) { return ( <div className="flex flex-col items-center justify-center min-h-[70vh]"> <p className="text-center text-muted-foreground">No battle looks available at the moment.</p> </div> ); } return ( <div className="w-full max-w-full px-2 sm:px-4 mx-auto"> <div className="grid gap-8 py-4"> {battleItems.map((battle) => ( <Card key={battle.id} className="overflow-hidden border rounded-lg"> <CardContent className="p-0"> <div className="p-4 border-b"> <div className="flex items-center gap-2"> <Avatar className="h-8 w-8"> <AvatarImage src={battle.avatar_url || ''} alt={battle.username || 'User'} /> <AvatarFallback>{(battle.username || 'U').charAt(0).toUpperCase()}</AvatarFallback> </Avatar> <div className="font-medium">{battle.username || 'Anonymous'}</div> </div> <p className="mt-2 text-sm text-gray-500">{battle.caption || 'Which option do you prefer?'}</p> </div> <div className="grid grid-cols-2 gap-1 p-1"> {/* Main Image */} {battle.image_url && ( <div className="aspect-square relative col-span-2"> <SupabaseImage src={battle.image_url} alt="Main look" fill className="object-cover rounded-md" /> </div> )} {/* Option 1 */} {battle.option1_url && ( <div className={`aspect-square relative cursor-pointer transition-all duration-200 ${battle.selectedOption === 1 ? 'ring-4 ring-primary' : 'hover:opacity-90'}`} onClick={() => handleSelection(battle.id, 1)} > <SupabaseImage src={battle.option1_url} alt="Option 1" fill className="object-cover rounded-md" /> </div> )} {/* Option 2 */} {battle.option2_url && ( <div className={`aspect-square relative cursor-pointer transition-all duration-200 ${battle.selectedOption === 2 ? 'ring-4 ring-primary' : 'hover:opacity-90'}`} onClick={() => handleSelection(battle.id, 2)} > <SupabaseImage src={battle.option2_url} alt="Option 2" fill className="object-cover rounded-md" /> </div> )} </div> <div className="p-4 flex justify-between"> <Button variant="outline" size="sm" disabled={!battle.option1_url} onClick={() => handleSelection(battle.id, 1)} className={battle.selectedOption === 1 ? 'bg-primary text-primary-foreground' : ''} > Option 1 </Button> <Button variant="outline" size="sm" disabled={!battle.option2_url} onClick={() => handleSelection(battle.id, 2)} className={battle.selectedOption === 2 ? 'bg-primary text-primary-foreground' : ''} > Option 2 </Button> </div> </CardContent> </Card> ))} </div> </div> ); } export default function BattlePage() { return ( <QueryClientProvider client={queryClient}> <div className="min-h-screen bg-background"> <div className="container max-w-full mx-auto pb-16"> <BattlePageContent /> </div> <BottomNav activeTab="/gallery/battle" /> </div> </QueryClientProvider> ); } 